<!DOCTYPE html>
<meta charset="utf-8">
<meta name=timeout content=long>
<!-- user agents are not required to support open features other than `noopener`
     and on some platforms position and size features don't make sense -->
<meta name="flags" content="may">
<title>Multi-Screen Window Placement test: Fullscreen</title>
<link rel="help" href="https://w3c.github.io/window-placement/">
This test uses multi-screen details to request fullscreen on different
displays and swap between them.<br>
It runs manually with `wpt serve` and a compatible browser.<br><br>
<button id="setUpButton">Request screen details</button>
<ul id="testButtons"></ul>
<ul id="logger"></ul>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<script src="resources/helpers.js"></script>

<script>
'use strict';

// Waits until `window` is located on `screen` or until 3 seconds elapses.
async function ensureWindowIsOnScreen(window, screen) {
  // Returns true if window `w` in on screen `s`.
  const isWindowOnScreen = async (w, s) => {
    const windowScreenDetails = await w.getScreenDetails();
    const center = {
      x: w.screenLeft + w.outerWidth / 2,
      y: w.screenTop + w.outerHeight / 2
    };
    return center.x >= s.left && (center.x < s.left + s.width) &&
      center.y >= s.top && (center.y < s.top + s.height) &&
      windowScreenDetails.currentScreen == s;
  }
  // Checks every 100ms if window `w` is on screen `s` up to 3s maximum.
  const waitForWindowOnScreen = async (w, s, resolve, timestamp = Date.now()) => {
    if (!w || w.closed || Date.now() - timestamp > 3000)
      resolve(false);
    else if (await isWindowOnScreen(w, s))
      resolve(true);
    else
      setTimeout(waitForWindowOnScreen.bind(this, w, s, resolve, timestamp), 100);
  }
  return new Promise(resolve => { waitForWindowOnScreen(window, screen, resolve); });
}

// Asserts that the the browser window is correctly positioned on `screen`.
// `assertFullscreen` specifies whether to expect the window to be fullscreen or not.
async function assertWindowOnScreen(test, screen, assertFullscreen) {

  // In chrome, the requestFullscreen promise may resolve before the
  // transition completes and the bounds may be incorect in the meantime.
  // Wait until the window is on the expected screen.
  // TODO(crbug.com/1330724) Remove this.
  await ensureWindowIsOnScreen(window, screen);

  assert_equals(document.fullscreenElement == document.documentElement,
    assertFullscreen);
  assert_equals(window.screen.availLeft, screen.availLeft);
  assert_equals(window.screen.availTop, screen.availTop);
  assert_equals(window.screen.availWidth, screen.availWidth);
  assert_equals(window.screen.availHeight, screen.availHeight);

  if (assertFullscreen) {
    // Window bounds should equal the bounds of the screen when in fullscreen.
    assert_equals(window.screenX, screen.availLeft);
    assert_equals(window.screenY, screen.availTop);
    assert_equals(window.innerWidth, screen.availWidth);
    assert_equals(window.innerHeight, screen.availHeight);
  } else {
    // Verify the window is somewhere within the specified screen
    assert_true(window.screenX >= screen.availLeft);
    assert_true(window.screenY >= screen.availTop);
    assert_true(window.screenX + window.innerWidth <= screen.availLeft + screen.availWidth);
    assert_true(window.screenY + window.innerHeight <= screen.availTop + screen.availHeight);
  }
}

promise_test(async setUpTest => {
  await setUpWindowPlacement(setUpTest, setUpButton);
  const screenDetails = await getScreenDetails();
  assert_true(!!screenDetails, 'Error getting screen details');
  for (const [i, fullscreenScreen] of screenDetails.screens.entries()) {
    const originalScreen = window.screen;
    const swapFullscreen =
      screenDetails.screens[(i + 1) % screenDetails.screens.length];
    let testName =
      `Fullscreen on '${fullscreenScreen.label}' and swap to ${swapFullscreen.label}`;
    promise_test(async fullscreenTest => {
      // Step 1: Enter Fullscreen.
      await addTestTriggerButtonAndAwaitClick(testButtons,
        `Step 1: ${testName}`,
        fullscreenTest);
      log(`Requesting fullscreen on screen: ${fullscreenScreen.label}`);
      await document.documentElement.requestFullscreen(
        { screen: fullscreenScreen }
      );
      await assertWindowOnScreen(fullscreenTest, fullscreenScreen, /*assertFullscreen*/true);
      // Step 2: Swap to another screen.
      await addTestTriggerButtonAndAwaitClick(testButtons,
        `Step 2: ${testName} (Swap screens)`,
        fullscreenTest);
      log(`Swapping fullscreen to screen: ${swapFullscreen.label}`);
      await document.documentElement.requestFullscreen(
        { screen: swapFullscreen }
      );
      await assertWindowOnScreen(fullscreenTest, swapFullscreen, /*assertFullscreen*/true);
      // Step 3: Exit fullscreen. Should restore window to `originalScreen`.
      await addTestTriggerButtonAndAwaitClick(testButtons,
        `Step 3: ${testName} (Exit Fullscreen)`,
        fullscreenTest);
      log(`Exiting fullscreen.`);
      document.exitFullscreen();
      await assertWindowOnScreen(fullscreenTest, originalScreen, /*assertFullscreen*/false);
    }, testName);
  }
}, 'Use multi-screen details to request fullscreen on target displays and swap between them');
</script>
